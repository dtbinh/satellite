function [trq,spd] = rw_dynamics(par,voltage,cur_cmd, spd, dt)
   
% Back EMF Saturation
iemf = (voltage - par.ke*spd)/ par.R;   % [V]
cur_cmd = rw_satcheck(cur_cmd,iemf);

% Internal Current
if(spd*cur_cmd >= 0)
    cur_int   = -par.ki*rw_get_friction(par,spd,'pos'); % in normal ops, this is friction + bemf
%     fprintf('[%.4f] Norm cur_cmd: %9.6f sign:%d\n',tspan(i),cur_cmd,sign(cur_cmd));
else
    cur_int   = -par.ki*rw_get_friction(par,spd,'neg'); % in intcur ops, this is int current + frict, 
    if(abs(cur_int)>abs(cur_cmd))
%         fprintf('[%.4f] Intc cur_cmd: %9.6f sign:%d \n',tspan(i),cur_cmd, sign(cur_cmd));
        cur_int   = -par.ki*rw_get_friction(par,spd,'neg'); % in intcur ops, this is int current + frict, 
    else
%         fprintf('[%.4f] Neu cur_cmd: %9.6f sign:%d\n',tspan(i),cur_cmd,sign(cur_cmd));
        cur_int   = -par.ki*rw_get_friction(par,spd,'pos');
    end
end


% Actual Current    
cur_motor = cur_cmd - cur_int;

% Actual Torque & Speed 
trq = par.km * cur_motor;   % [Nm] Torque Generated by Current (includes friction effect)
spd = spd + trq/par.J * dt; % [rad/s] wheel speed


end