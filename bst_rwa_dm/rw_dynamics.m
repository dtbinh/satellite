function [trq,spd,cur_int] = rw_dynamics(par,voltage,cur_cmd, spd, dt)

persistent cur_motor

% Back EMF Saturation
iemf = (voltage - par.ke*spd)/ par.R;   % [V]
cur_cmd = rw_satcheck(cur_cmd,iemf);

% Internal Current
if(spd*cur_cmd >= 0)
    cur_int   = -par.ki*rw_get_friction(par,spd,'pos'); % in normal ops, this is friction + bemf
%      fprintf('Norm cur_cmd: %9.6f sign:%d\n',cur_cmd,sign(cur_cmd));
else
    cur_int   = -par.ki*rw_get_friction(par,spd,'ke'); % in intcur ops, this is int current + frict, 
    vol_motor = cur_motor*par.R;      % Will always be against the rotation
    vol_emf   = par.ke*spd;               % Will always be against the rotation
    vol_int   = sign(cur_cmd)*voltage - vol_emf - vol_motor;
    vol_stat  = abs(vol_int)>abs(voltage);
    
%     fprintf('vol_in: %.3f vol_int: %.3f vol_emf: %.3f vol_motor: %.3f vol_stat:%d\n',sign(cur_cmd)*voltage, vol_int, vol_emf, vol_motor,vol_stat);
    
    if (abs(cur_int)>abs(cur_cmd))
%         fprintf('Int cur_cmd: %9.6f sign:%d \n',cur_cmd, sign(cur_cmd));
        cur_int   = -par.ki*rw_get_friction(par,spd,'neg'); % in intcur ops, this is int current + frict, 
    else
        
%         fprintf('Neu cur_cmd: %9.6f sign:%d\n',cur_cmd,sign(cur_cmd));
        cur_int   = -par.ki*rw_get_friction(par,spd,'pos');
    end
end


% Actual Current    
cur_motor = cur_cmd - cur_int;

% Actual Torque & Speed 
trq = par.km * cur_motor;   % [Nm] Torque Generated by Current (includes friction effect)
spd = spd + trq/par.J * dt; % [rad/s] wheel speed

end